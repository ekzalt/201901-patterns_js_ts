# Development

## Design Patterns in JavaScript and TypeScript

### Reactor

Reactor Pattern `./patterns/reactor`

Oсновные идеи данного шаблона:

- однопоточная архитектура
- неблокирующие операции ввода/вывода.

Реализуется разными способами посредством использования *Event Loop* - с помошью Callback, Observer, Promise, Async/Await.

### Revealing Module

Revealing Module Pattern `./patterns/module`

Одной из основных проблем языка JavaScript является отсутствие пространств имен. Популярным методом решения этой проблемы является шаблон *Revealing Module* (Открытый модуль). Для создания приватных свойств и методов используется ограниченная область видимости внутри функции и замыкания. Модульность платформы *Node.js* активно поощряет следование *принципу единственной ответственности* (Single Responsibility Principle, SRP): каждый модуль должен отвечать только за одну функциональную возможность, и эта ответственность должна быть
полностью реализована этим модулем.

### Substack

Экспортируйте основные функциональные возможности модуля в виде единственной функции. Экспортированная функция используется как пространство имен для прочих вспомогательных возможностей. Экспорт *Конструктора / Класса* или *Фабричной функции* - это частные случаи этого общего шаблона.

### Callback

Callback Pattern `./patterns/callback`

*Обратные вызовы* – это функции, вызываемые для передачи результата операции, и это именно то, что необходимо при работе с асинхронными операциями. Они заменяют использование инструкции return, которая всегда выполняется синхронно.

В JavaScript принято функцию-Callback передавать последним аргументом. А в сам Callback передавать 2 аргумента: первый - это всегда *объект возможной ошибки*, а второй - *возможный результат*.

**Будьте внимательны!** Callback должен быть или всегда синхронный, во всех случаях, или всегда асинхронный.

### Promise

Promise Pattern `./patterns/promise`

*Promise* является абстракцией, позволяющей функциям возвращать объект-Promise, представляющий конечный результат асинхронной операции. Мы говорим, что объект-Promise *ожидает*, если асинхронная операция еще не завершилась, *выполнен* – если операция завершилась успешно, и *отклонен* – если возникла ошибка.

### Async/await

Async/await Pattern `./patterns/async-await`

Теперь разработчики могут писать *асинхронный* код, который *выглядит как синхронный* в каждой асинхронной операции, ожидающей результатов перед выполнением следующего оператора. Код стал похож на шаблон **Remote Procedure Call**, [RPC](https://ru.wikipedia.org/wiki/Remote_Procedure_Call) из Java и С#.

### Observer

Observer Pattern `./patterns/observer`

*Observer* определяет субъект, способный уведомить ряд наблюдателей (или обработчиков) об изменении своего состояния. *Observer* является одним из столпов платформы и абсолютно необходимым условием использования многих не входящих в ядро и пользовательских модулей. *Observer* является идеальным решением для моделирования реактивной природы платформы *Node.js*.

Обычно есть 2 типа передачи данных в *Observer*:

1. когда новые данные насильно внедряются в объект-наблюдатель (подписчик), тем самым меняя его состояние извне.
2. когда подписчик нотифицируется, что новые данные есть, и он обращается к ним сам, когда ему удобно.
3. *Node.js* предоставляет третий компромисный вариант - данные получают все подписчики, но данные не внедряются. А подписчик сам решает, проигнорировать эти данные или обработать.

### Streams

Streams Pattern `./patterns/streams`

*Потоки данных* (streams) являются одним из наиболее важных компонентов и шаблонов *Node.js*. В платформах, основанных на *событиях*, таких как Node.js, наиболее эффективным
способом обработки *ввода/вывода* являются работа в режиме реального времени - получение входных данных по мере их доступности и отправка выходных данных по мере их создания приложением.

### Adapter

Adapter Pattern `./patterns/adapter`

*Адаптер* преобразует один интерфейс класса к другому интерфейсу, на который расчитывает клиент. Адаптер обеспечивает совместную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.

### Factory

Factory Pattern `./patterns/factory`

Представлены 3 варианта шаблона (отличаются от классического трактования в силу особенностей JavaScript):

- фабричный метод, принадлежит самому классу, обычно используется для создания экземпляра `Singleton`
- фабричная функция, простая функция создающая экземпляр, для поддержки `Dependency Injection` нужно создать замыкание
- фабрика / фабричный класс - классическая реализация, поддерживающая `Dependency Injection`

Главное предназначение Фабрики - инкапсулировать создание экзепляра вместе со всей логикой его создания в одном месте кода (DRY).

### Proxy

Proxy Pattern `./patterns/proxy`

*Прокси* – это объект, управляющий доступом к другому объекту, который называется *субъектом*. Прокси и субъект имеют *идентичные интерфейсы*, и это позволяет прозрачно подменять одного другим: фактически этот шаблон имеет другое название: *суррогат*. Прокси перехватывает все или часть операций, которые должны выполняться субъектом, расширяя или дополняя его модель поведения.

Прокси могут пригодиться в нескольких ситуациях, например:

- **проверка данных**: прокси проверяет допустимость входных данных перед отправкой субъекту;
- **безопасность**: прокси проверяет наличие у клиента достаточных прав для выполнения операции;
- **кэширование**: прокси хранит внутренний кэш, вызывая субъекта, только если затребованные данные еще отсутствуют в кэше;
- **отложенная инициализация**: если создание субъекта сопряжено с большими накладными расходами, прокси может отложить эту операцию до момента, когда это станет действительно необходимо;
- **журналирование**: прокси перехватывает вызовы методов и их параметры, регистрируя их в журнале;
- **обращение к удаленным объектам**: прокси может обеспечить работу с удаленным объектом как с локальным.

### Decorator

Decorator Pattern `./patterns/decorator`

*Декоратор* – структурный шаблон, суть которого заключается в динамическом расширении модели поведения существующего объекта. Он отличается от классического наследования, добавляя новые функциональные возможности не ко всем объектам одного и того же класса, а только к явно декорированным экземплярам.

[Декораторы в TypeScript](https://www.typescriptlang.org/docs/handbook/decorators.html) как [Аннотации в Java](https://en.wikipedia.org/wiki/Java_annotation).
